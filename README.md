**this is a silly little game about finding the right procedurally generated person in an absurd procedurally generated world**

٩( ᐛ )و

*scripts:*  Assets/scripts  
*all the 3d models + matirials and a skybox:*  Assets/assets (yeah, woow, I know)  
*music:*  Assets/music

![dudes_spinning_futageee (1)](https://github.com/user-attachments/assets/ec8ad38f-1d3a-4893-8bb3-a249e85567a9)

an essey in Russian about the game and it's main systems:


__• Идея, её возникновение, геймплей:__

Идея возникла из темы геймджема, в котором мне хотелось участвовать – “what’s behind the door?” мне сразу представился домик с дверями и окнами, по которому ходят странные процедурно генерируемые чувачки, игроку нужно найти какого-то конкретного чувачка, открывая окна и двери, ища нужное лицо, что-то вроде “найди предмет”, но процедурное. Это очень иронично, потому что в результате у меня не хватило времени чтобы добавить ни двери, ни стены вообще. Незадолго до геймджема я создала свою первую 3d модель, у меня было много энтузиазма насчт этого, поэтому я решила что игра будет трёхмерной. Также мне ещё давно была очень интересна процедурная анимация, и, раз я решила что игра будет в 3d, у меня как раз была возможность воспользоваться встроенной в Unity системой inverse kinematics. И в результате получилось,что в игре нет вообще ни одного кадра анимации, она вся, так или иначе, выполнена через код 

__• Процедурная анимация шагания *( Assets/scripts/dudes_animatios/prosigiral_walking )*:__

Это было первое, что я сделала. Сначала я использовала обычную для процедурной анимации технику, с помощью которой создают всяких там роботических пауков, по сути это передвижение ноги когда она слишком сильно отдаляется от фиксированной к телу позиции. Но как ни странно, в результате чувачки выглядели как роботы, и к тому же ноги отставали от тела.
Поэтому я создала свою технику: сначала нужно нарисовать невидимый эллипс, используя двухмерное расположение концов ног как центры двух образующих эллипс окружностей, затем проверить, находится ли проекция центра чувачка внутри этого эллипса, и если нет, переставить самую дальнюю ногу в точку, противоположную другой ноге относительно проекции центра чувачка. Получившуюся позицию я смешиваю с обычной позицией ноги чтобы сгладить результат и заставить чувачков немного лучше поворачиваться, и проецирую на землю. Потом я плавно, по дуге переставляю ногу в полученную позицию используя библиотеку DOTween. Потом на это я ещё нанизала чередование ног, минимальное расстояние и минимальный и максимальный интервал шага. 
Результат всё ещё выглядит немного странно, но по-моему в хорошем смысле :)

__• Движение, похожее на толпу *( Assets/scripts/dudes_animatios/movement_boids_script.cs )*:__

Для создания этой системы я вдохновилась концептом Boids, а именно самым первым их правилом, правилом избегания. По нему вектор движения боида складывается из векторов, которые направлены от видимых боидом объектов, и которые тем больше, чем объекты ближе.
В моей имплементации каждый из чувачков независимо выпускает лучи, чтобы смотреть по сторонам, потом рассчитывает вектор движения просто исходя из точек, в которых лучи что-то задели. Для движения по лестницам я просто пускаю луч от чувачка вниз, обнаруживаю пол, и поднимаю чувачка на фиксированную высоту от него, всё остальное происходит само если правильно расставить коллайдеры.
Почему-то, несмотря на кажущуюся простоту, имплементация этой системы заняла у меня оочень много сил и времени, но в результате получилось прямо так, как мне хотелось! (если не считать, что чувачки могут иногда ходить кругами в одном месте, но я считаю, у них должно быть такое право:)

__• Процедурная генерация чувачков и их распознавание *( Assets/scripts/dudes_faces )*:__	

Чтобы создать рандомного чувачка сначала нужны модели разных частей тела, я выбрала 4 части тела: голову, глаза, нос и рот (ноги у всех одинаковые, потому что было бы очень сложно каждый раз заново создавать скелет и rig). Всего я успела сделать по 5 моделей головы, глаз и рта, и 4 модели носов, так что получается, всего в игре может получится ровно 500 индивидуальных чувачков! Дальше остаётся просто создть список (array) с 3d моделями для каждой части тела, выбрать по одному рандомному элементу из каждого, и всё!
Но чтобы генерировать неповторяющихся чувачков, иметь возможность выбирать для поимки чувачка, который точно есть в сцене, отдельно визуально его показать, и понять, пойман ли правильный, нужно создать что-то вроде id, который будет индивидуальным для каждого чувачка. Я решила выбрать в качестве такого id список из индексов каждой отдельной 3d модели части тела в списке этой части тела, и по какой-то уже забытой причине назвала его в коде prop. Получается, этот prop состоит из 4 цифр из-за 4 частей тела, и теперь я имею возможность отслеживать существующих чуваков.
Моя конкретная имплементация заключалась в том, что сначала я генерирую сет со всеми возможными prop’ами, затем, при генерации чувачка выбираю один возможный prop, удаляю его из общего сета, добавляю в сет заспавненных и присваиваю чувачку, легко нахожу соответствующие 3d модели частей тела, и спавню на чувачка. Теперь чувачок ходит красивенький, а я могу выбрать из сета заспавненных чувачка, которого нужно найти, и легко вывести его на экран, прикрепив к камере, чтобы двигался вместе с ней (ещё я сделала так, чтобы он скейлился тоже вместе с ней). Для поимки или не поимки чувачка, я просто пускаю лучи из камеры к курсору и проверяю, соответствует ли prop, который нужно найти, prop’у чувачка, на которого кликнули.

__• Процедурная генерация уровней *( Assets/scripts/geniration )*:__

Создавая эту систему, я прошла через много разных идей алгоритмов, но остановилась на самом простом.
Почему-то получилось, что я создаю домики сверху вниз, поэтому алгоритм начинается в точке с координатами (0, *высота верхнего этажа*, 0), это координаты первой плитки дома, которая также станет первой “плиткой отсчёта”, она добавляется в список всех плиток этажа, дальше начинается сам алгоритм, он работает так:		

  1. У плитки отсчета находятся все возможные соседи в плоскости этажа и записываются в сет.
  2. Из сета всех соседей исключается сет всех плиток этажа (что легко если использовать HashSet.ExceptWith()), чтобы найти сет возможных соседей.
  3.Если результат получается пустым, алгоритм перескакивает сразу в пятый пункт (наверно это одна из его главных слабостей).
  4. А если сет возможных соседей не пустой, из него случайно выбирается одна позиция плитки, и добавляется в сет всех плиток этажа.
  5. Из сета всех плиток этажа случайно избирается новая плитка отсчёта, и алгоритм возвращается к первому пункту.

Остаётся только закончить этот алгоритм когда у меня накопится нужное количество плиток, и пол одного этажа готов! Дальше обязательно нужно расставить стены, потому что система хождения опирается на это. Для этого нужно всего лишь прогнать почти такой же алгоритм, но уже используя все заспавненные позиции плиток, и ища не одного случайного соседа, а всех, и записывая их в список. Для лестницы я просто беру рандомную стену, удаляю, и ставлю на её месте на нужной высоте модельку лестницы, потом рассчитываю плитку, которая следует после лестницы, и она становится следующей плиткой отсчёта. И так продолжается на протяжении стольких этажей, сколько мне нужно. Потом позиции плиток отправляются спавнеру, и он генерирует нужное количество чувачков па рандомных местах.
Чтобы спавнить стены и лестницы, мне нужно знать не только позицию, но и вращение объектов, а в Unity, Transform (насколько я понимаю) не может существовать отдельно от игрового объекта, поэтому у меня бы не получилось провернуть этот модный приём с сетами, тк игровые объекты по умолчанию разные, даже если находятся в одном месте. Это причина, по которой мне не удалось реализовать стены, окна и двери, как мне хотелось с самого начала. Хотя сейчас я поняла, что могла бы использовать 
Диалоговая система / туториал:
Как я уже сказала, в игре нет ни одного кадра анимации, все анимации туториала я делала через код с помощю библиотеки DOTween. И это было довольно больно, но я создала для себя набор функций, которые были для меня как строительные блоки.

__• Художественное оформление *( Assets/assets )*:__

Всё, связанное с визуалом, все 3d модели, а также диалоги в туториале, я создала сама. А музыку для главного меню написал человек, с которым я до этого познакомилась на участии в геймджеме (остальные звуки я, к сожалению, не успела добавить.
